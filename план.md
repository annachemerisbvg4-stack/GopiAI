**План действий для стабилизации переключения провайдеров и получения ответов**:

**Цель:** Устранить "прыгающие" провайдеры, случайные выборы (например, Kimi вместо Gemini), пропадающие ответы и обеспечить стабильную работу при переключении конфигураций.

**Основные направления работ:**

1.  **Синхронизация UI ⇆ Backend:**
    *   **Цель:** Гарантировать, что и UI, и Backend всегда используют одинаковые `current_provider` и `current_model_id`.
    *   **Задачи:**
        *   **1.1.** Создать файл состояния `~/.gopiai_state.json`.
            *   Хранить в нем поля: `provider`, `model_id`.
        *   **1.2.** Backend:
            *   При запуске читать `~/.gopiai_state.json` (например, через функцию `load_state` из модуля `state_manager.py`).
            *   Устанавливать прочитанные значения (`provider`, `model_id`) в `UsageTracker` (например, через `set_current_provider` и `register_use` или аналогичные механизмы).
        *   **1.3.** Добавить REST-эндпоинты в Backend (FastAPI):
            *   `GET /internal/models?provider={provider_name}`: Возвращает список доступных моделей для указанного провайдера (например, используя `llm_rotation_config.get_available_models(provider)`).
            *   `POST /internal/state`: Принимает JSON `{ "provider": "...", "model_id": "..." }`, сохраняет его в `~/.gopiai_state.json` (например, через функцию `update_state`).
        *   **1.4.** UI-виджет:
            *   При смене провайдера/модели (например, в обработчике события `QComboBox`) отправлять POST-запрос на `/internal/state` с новыми значениями.
            *   При нажатии кнопки "Refresh" (или аналогичном событии) отправлять GET-запрос на `/internal/models?provider={current_provider}` и обновлять выпадающий список моделей *только* данными из этого ответа (убрать локальное кэширование).
            *   *Уточнение:* При переключении провайдера UI должен сначала сохранить состояние (POST), а затем обновить список моделей (GET).

2.  **Устойчивый `UsageTracker`:**
    *   **Цель:** Корректно отслеживать и сбрасывать лимиты при переключении провайдеров, предотвращать "прилипание" лимитов, добавить механизм мягкого черного списка.
    *   **Задачи:**
        *   **2.1.** Добавить метод `set_current_provider(name)`:
            *   Должен устанавливать текущий провайдер.
            *   Сбрасывать окна лимитов (rpm/tpm) *только* для моделей, принадлежащих *другим* провайдерам, не трогая текущий.
        *   **2.2.** Модифицировать метод `register_use()`:
            *   Добавить поле `last_provider` для хранения провайдера, от имени которого была совершена последняя "регистрация использования".
            *   При вызове `register_use()` проверять, совпадает ли текущий провайдер с `last_provider`. Если нет – сбрасывать накопленные лимиты для *предыдущего* провайдера, чтобы они не "прилипали".
        *   **2.3.** Реализовать "мягкий blacklist":
            *   Если RPM (запросов в минуту) для конкретной модели превышает лимит * 1.5, то:
                *   Эта модель помечается как недоступная (добавляется во временный черный список).
                *   Блокировка действует `N` секунд, где `N = 60 / rpm_limit`.
            *   По истечении времени `N` модель автоматически разблокируется.
        *   **2.4.** Добавить метод `is_blacklisted(model_id)`:
            *   Проверяет, находится ли указанная модель в черном списке.
            *   Необходим для тестирования.
        *   **2.5.** (Уже добавлено, но убедиться) Добавить свойства для обратной совместимости:
            *   `@property def models(self)`: Возвращает глобальный список моделей (`MODELS`).
            *   `def get_blacklist_status(self)`: Возвращает статус черного списка (например, пустой словарь `{}` если не реализовано полностью, или актуальные данные).

3.  **Надёжный цикл API-ключей (`.env`):**
    *   **Цель:** Предотвратить дублирование строк с ключами в файле `.env` и обеспечить валидацию ключей.
    *   **Задачи:**
        *   **3.1.** UI при сохранении ключа:
            *   Читать файл `.env`.
            *   Искать строку, начинающуюся с соответствующего `ENV_VAR` (например, `OPENROUTER_API_KEY=`).
            *   Если строка найдена – заменять её новой.
            *   Если строка не найдена – добавлять новую строку.
            *   Записывать изменения обратно в `.env`. *Никаких дубликатов.*
        *   **3.2.** Backend при чтении ключей:
            *   Выполнять валидацию: ключ не пустой, длина >= 20 символов, нет пробелов.
            *   При обнаружении ошибки: выводить `Warning` в лог, но *не завершать* процесс.
            *   Продолжать работу с пустым или невалидным ключом (если логика позволяет) или корректно обрабатывать отсутствие ключа.

4.  **Автотесты + CI:**
    *   **Цель:** Создать автоматизированные тесты и настроить CI/CD для предотвращения регрессий.
    *   **Задачи:**
        *   **4.1.** Написать `pytest` тесты:
            *   `test_switch_provider_preserves_limits`: Проверяет, что лимиты корректно сбрасываются/сохраняются при переключении провайдеров.
            *   `test_model_blacklist_unlocks`: Проверяет механизм мягкого черного списка и его автоматическую разблокировку.
            *   `test_env_key_cycle`: Проверяет корректность записи/чтения/валидации API-ключей в `.env`.
        *   **4.2.** Настроить GitHub Action:
            *   Запускать `pytest` набор (backend-unit-tests).
            *   Запускать UI-виджет в headless-режиме (если возможно), отправлять тестовый запрос ("hello") и проверять успешный HTTP-ответ (например, 200 OK).

**Порядок реализации:**
Реализация должна идти строго по блокам: **1 → 2 → 3 → 4**. Каждый блок необходимо тщательно тестировать локально перед переходом к следующему, чтобы обеспечить стабильность на каждом этапе.

**Дополнительные замечания:**
*   Убедиться, что все необходимые "shim'ы" и обратная совместимость (например, `select_llm_model_safe`, `rate_limit_monitor`, `LLM_MODELS_CONFIG`) работают корректно.
*   Модуль `state_manager.py` с функциями `load_state`, `save_state`, `get_state_path` уже создан и готов к использованию.
*   `UsageTracker` уже содержит заглушки/реализации `models` и `get_blacklist_status`.
